[gd_resource type="Shader" format=3 uid="uid://cmuvypkd7tc5a"]

[resource]
code = "shader_type canvas_item;
render_mode unshaded;

uniform sampler2D palette_tex : source_color;
uniform int palette_colors_amount : hint_range(1, 100, 1);

uniform float outline_width : hint_range(0.0, 40.0) = 1.0;
uniform vec4 outline_color : source_color = vec4(0.0, 0.0, 0.0, 1.0);
uniform bool use_8way_kernel = false;
uniform bool normalize_outline = false;

vec3 palette_limiter (in vec3 albedo){
	float estimation_cutoff = 0.001;
	vec3 closest_color;
	float min_dist = 2.0;
	float n = float(palette_colors_amount);
	
	for (int i=0; i<palette_colors_amount; i++ ){
		float index = 1.000/(2.000*n)+float(i)/n;
		vec3 index_color = texture(palette_tex, vec2(index,0.5)).rgb;
		float dist = length(index_color - albedo);
		if (dist < min_dist) {
			min_dist = dist;
			closest_color = index_color;
			if (min_dist < estimation_cutoff){
				return closest_color;
			}
		}
	}
	return closest_color;
}

void fragment() {
    float uv_dist = distance(UV, vec2(0.5)) * 2.0;
	
	vec4 texture_col = texture(TEXTURE, UV);
	vec4 col = COLOR * texture_col;
	
	vec3 limited_col = palette_limiter(col.xyz);
	vec2 ps = TEXTURE_PIXEL_SIZE * outline_width;
	float a;
	float maxa = col.a;
	float mina = col.a;
	
	for(float y = -1.0; y <= 1.0; y++) {
		for(float x = -1.0; x <= 1.0; x++) {
			if(vec2(x,y) == vec2(0.0)) continue;
			if(!use_8way_kernel){
				if(x != 0.0 && y != 0.0) continue;
			}
			
			vec2 displacement;
			if(normalize_outline) displacement = normalize(vec2(x,y))*ps;
			else displacement = vec2(x,y)*ps;
			
			a = texture(TEXTURE, UV + displacement).a;
			maxa = max(a, maxa);
			mina = min(a, mina);
		}
	}
	
	if(col.a == 0.0){
		COLOR = mix(col, outline_color, maxa-mina);
	} else {
		COLOR = vec4(limited_col, col.a);
	}
}"
